# Vue 部分

## 基础篇

### 1、Vue 的优点
1. 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十k
2. 简单易学：中文文档油耗不存在语言障碍，易于理解和学习
3. 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单
4. 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势
5. 视图、数据、瑞吉分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作
6. 虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种更高效的方式； 
7. 运行速度更快：相比较于 react 而言同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。

### 2、说一下 Vue 的生命周期
每个Vue 实例从开始创建、初始化数据、 编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等⼀系列过程称之为它的的⽣命周期。

共有8个阶段，分别是：
- 创建前beforeCreate
- 创建后created
- 挂载前beforeMount
- 挂载后mounted
- 更新前beforeUpdate
- 更新后updated
- 销毁前beforeDestroy
- 销毁后destroyed

**详解：**
1. beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到 data、computed、watch、methods 上的方法和数据。 
2. created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染 得节点还未挂载到 DOM，所以不能访问到 $el 属性。 
3. beforeMount（挂载前）：在挂载开始之前被调用，相关的 render 函数首次被调用。vue已经将模板字符串编译成内存DOM，模板已经编译完成，还没有渲染到页面上。
4. mounted（挂载后）： el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。创建阶段完成，页面渲染完毕，进入运行阶段。此时我们可以通过$refs来访问到真实的DOM结构。
5. beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。 
6. updated（更新后）：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件DOM已经更新，所以可以执行依赖于 DOM 的操作。然而 在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更 新无限循环。该钩子在服务器端渲染期间不被调用。 
7. beforeDestroy（销毁前）：实例销毁之前调用。在这一步实例仍然完全可用，this 仍能获取到实例。 
8. destroyed（销毁后）：实例销毁后调用，调用后 Vue 实例指向的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。

另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。


### 3、Vue 子组件和父组件的声明周期钩子的执行顺序
- 加载渲染过程： 
  1. 父组件 beforeCreate 
  2. 父组件 created 
  3. 父组件 beforeMount 
  4. 子组件 beforeCreate 
  5. 子组件 created 
  6. 子组件 beforeMount 
  7. 子组件 mounted 
  8. 父组件 mounted

- 更新过程： 
  1. 父组件 beforeUpdate
  2. 子组件 beforeUpdate
  3. 子组件 updated
  4. 父组件 updated

- 销毁过程:
  1. 父组件 beforeDestroy 
  2. 子组件 beforeDestroy 
  3. 子组件 destroyed 
  4. 父组件 destoryed

### 4、Vue 中子组件可以直接改变父组件的数据吗？为什么？
子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。
如果你在子组件中修改父组件的数据了，Vue 会在浏览器的控制台中发出警告。因为Vue 提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据 流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。 
我们只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件自行修改。
（小tips： 如果你讲vue源码中警告逻辑注释掉，强行修改父组件值，还是能成功的）

### 5、一般在哪个生命周期请求异步数据
我们可以在钩子函数 created、beforeMount、mounted 中进行调用， 因为在这三个钩子函数中 data 已经创建，可以将服务端端返回的数据进行赋值。 
推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 
1、能更快获取到服务端数据，减少页面加载时间，用户体验更好
2、SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性

### 6、keep-alive 中的生命周期哪些
keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存 —— 在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。
如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期： deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 

当组件被换掉时，会被缓存到内存中，触发 deactivated 钩子函数 
当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数

### 7、v-if 和 v-for 哪个优先级更高？如果同时出现，应如何优化？
v-for 优先于 v-if 被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。 
要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环。
如果条件出现在循环内部，可使用计算属性提前过滤掉那些不需要显示的项。


### 8、created 和 mounted 的区别
created:在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。 
mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。

### 9、对 Vue 组件化的理解
1. 组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用
2. 组件化开发能大幅提高应用开发效率、测试性、复用性等
3. 组件使用按分类有：页面组件、业务组件、通用组件
4. vue 的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于 VueComponent，扩展于 Vue
5. vue 中常见组件化技术有：属性 prop、自定义事件、插槽等，它们主要用于组件通信、扩展
6. 合理的划分组件，有助于提升应用性能
7. 组件应该是高内聚、低耦合的
8. 遵循单向数据流的原则

### 10、对 Vue 设计原则的理解
1. 渐进式 JavaScript 框架：与其它大型框架不同的是，Vue 被设计 为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 
2. 易用性：vue 提供数据响应式、声明式模板语法和基于配置的组件 系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写 js、html 和 css 就能轻松编写 vue 应用。
3. 灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要 vue 核心特性即可完成功能。随着应用规模不断扩大， 我们才可能逐渐引入路由、状态管理、vue-cli 等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。 
4. 高效性：超快的虚拟 DOM 和 diff算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3 中引入 Proxy 对数据响应式进行改进，优化编译器对静态内容编译进行改进都会让 vue 更加高效。

### 11、Vue 中 key 的作用
vue 中 key 值的作用可以分为两种情况来考虑：
**第一种情况**是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的 输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来 唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。 这个时候 key 的作用是用来标识一个独立的元素。
**第二种情况**是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来方便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。
**总结**
key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可 以更准确、更快速。
更准确：因为带 key 就不是使用“就地更新”的策略了，在 sameNode 函数出现 a.key === b.key 时可以避免就地复用的情况。所以会更加准确。 
更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

### 12、Vue 单页应用与多页应用的区别

SPA 单页面应用（SinglePage Web Application）：指只有一个主页面的应用，一开始只需要加载一次 js、css 等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。 
MPA 多页面应用 （MultiPage Application）：指有多个独立页面的应用，每个页面必须重复加载 js、css 等相关资源。多页应用跳转需要整页资源刷新。
![](http://rr7byi9s5.hb-bkt.clouddn.com/WechatIMG2.png)


### 13、MVVM 的优缺点
优点：
1. 提⾼可测试性: ViewModel 的存在可以帮助开发者更好地编写测试代码。
2. 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定不同的视图（View）。
3. ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动 dom 操作中解放。

缺点：
1. Bug 很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了， 有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位出问题的原始地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打 debug 的。
2. 内存花费高：⼀个⼤的模块中 model 也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性。但需要⻓期持有 model ，不释放内存就造成了花费更多的内存。
3. 对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼。


### 14、路由的 hash 和 history 模式的区别

Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模式是 hash 模式。
#### hash 模式
**简介：**hash 模式是开发中默认的模式，它的 URL 带着一个#，例如： http://www.abc.com/#/vue，它的 hash 值就是#/vue。 
**特点：**hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash 路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。 
**原理：** hash 模式的主要原理就是 onhashchange()事件：
```js
  window.onhashchange = function(e){
    let hash = location.hash.slice(1)
    console.log(hash)
  }
``` 
使用 onhashchange()事件的好处就是，在页面的 hash 值发生变化时， 无需向后端发起请求，window 就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash 值变化对应的 URL 都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的 hash 值和对应的 URL 关联起来了。

#### history 模式
**简介：** history 模式的 URL 中没有#，它使用的是传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个 URL，然后做出相应的逻辑处理。
**特点：** 当使用 history 模式时 ， URL 就像这样： http://abc.com/user/id。相比 hash 模式更加好看。但是，history 模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。
**原理：** history api 可以分为两大部分，切换历史状态和修改历史状态。
修改历史状态： 包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。如果要做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。只是当他们进行修改时，虽然修改了 url，但浏览器不会立即向后端发送请求。 
切换历史状态： 包括 forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。 虽然 history 模式丢弃了丑陋的#。但是它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。 如果想要切换到 history 模式，就要进行以下配置（后端也要进行配置）：
前端：
```js
  const router = new VueRouter({
    mode:'history',
    routes:[]
  }) 
```
Nginx配置示例：
```nginx
  location / {
    try_files $uri $uri/ /index.html;
  }
```

#### 对比
调用 history.pushState() 相比于直接修改 hash，存在以下优势: 
1. pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
2. pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动 作将记录添加到栈中
3. pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串
4. pushState() 可额外设置 title 属性供后续使用; hash 模式下仅 hash 符号之前的 url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误
5. history 模式下， 前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的路由处理，将返回 404 错误。
hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际 情况选择性的使用。

### 15、Vuex 和 localStorage 的区别
1. 最重要的区别-存储位置
vuex 存储在内存中，localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON 的 stringify 和 parse 方法进行处理。 读取内存比读取硬盘速度要快。
2. 应用场景
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex 用于组件之间的传值。 localstorage 是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。 Vuex 能做到数据的响应式，localstorage 不能。
3. 数据时效性
刷新页面时 vuex 存储的值会丢失，localstorage 不会。 注意：对于不变的数据确实可以用 localstorage 可以代替 vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage 无法做到。